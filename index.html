<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>TinZr ECG Viewer (Web)</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#020817">

<style>
  :root{
    --bg:#020817;
    --panel:#0b1220;
    --text:#E3F2FD;
    --muted:#A8B3CF;
    --accent:#5aa7ff;
    --curve:#F5F5F5;
    --danger:#FF5252;
    --dangerFill:#FFCDD2;
    --pill: rgba(0,0,0,0.45);
    --border: rgba(255,255,255,0.10);
  }

  *, *::before, *::after { box-sizing: border-box; }

  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overflow-x:hidden;
  }

  .app{
    width: min(600px, calc(100vw - 24px));
    height: calc(100vh - 24px);
    margin: 12px auto;
    display:flex;
    flex-direction:column;
    gap:10px;
    padding: calc(12px + env(safe-area-inset-top)) 16px calc(12px + env(safe-area-inset-bottom)) 16px;
    background: transparent;
    border-radius: 16px;
  }

  .header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding-bottom:4px;
  }
  .title{
    font-size: 22px;
    font-weight: 700;
    color: var(--text);
  }

  .battBtn{
    cursor:pointer;
    user-select:none;
    border:1px solid var(--border);
    background: rgba(255,255,255,0.04);
    color: var(--text);
    padding:10px 14px;
    border-radius: 12px;
    font-weight: 800;
    min-width: 92px;
    text-align:center;
  }

  .panel{
    background: rgba(255,255,255,0.02);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 10px;
  }

  .grid{
    display:grid;
    grid-template-columns: 160px 1fr;
    gap:10px;
    align-items:center;
  }

  .row2{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:14px;
    align-items:center;
    margin-top:10px;
  }

  .btn{
    cursor:pointer;
    border:1px solid var(--border);
    background: rgba(255,255,255,0.05);
    color: var(--text);
    padding:12px 14px;
    border-radius: 12px;
    font-weight: 900;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:disabled{ opacity:0.5; cursor:not-allowed; }

  .selectLike{
    width:100%;
    border:1px solid var(--border);
    background: rgba(0,0,0,0.22);
    color: var(--text);
    padding:12px 14px;
    border-radius: 12px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }

  .toggleWrap{
    display:flex; align-items:center; justify-content:space-between;
    border:1px solid var(--border);
    background: rgba(0,0,0,0.16);
    padding:12px 14px;
    border-radius: 12px;
  }
  .toggleWrap span{color:var(--text); font-weight:900;}

  .toggle{
    width:50px; height:28px;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    border:1px solid var(--border);
    position:relative;
    cursor:pointer;
    flex: 0 0 auto;
    -webkit-tap-highlight-color: transparent;
  }
  .knob{
    position:absolute; top:3px; left:3px;
    width:22px; height:22px; border-radius:999px;
    background: rgba(255,255,255,0.85);
    transition: transform 120ms ease;
  }
  .toggle.on{ background: rgba(90,167,255,0.35); }
  .toggle.on .knob{ transform: translateX(22px); background: rgba(255,255,255,0.95); }

  .statusRow{
    display:flex; align-items:center; gap:10px; margin-top:10px;
  }
  .status{
    flex:1;
    border:1px solid var(--border);
    background: rgba(0,0,0,0.16);
    border-radius: 12px;
    padding: 12px 14px;
    color: var(--text);
    font-weight: 800;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }

  /* âœ… NEW: appears only after recording finishes */
  .saveBtn{
    display:none;
    margin-top:10px;
    width:100%;
    border:1px solid rgba(90,167,255,0.45);
    background: rgba(90,167,255,0.18);
    color: #E3F2FD;
    padding:14px 14px;
    border-radius: 12px;
    font-weight: 1000;
  }

  .plotWrap{
    position:relative;
    flex:1;
    background: var(--bg);
    border:1px solid var(--border);
    border-radius: 16px;
    overflow:hidden;
    min-height: 180px;
  }
  canvas{ display:block; width:100%; height:100%; }

  .hud{
    position:absolute; right:10px; top:10px;
    background: var(--pill);
    padding:4px 8px;
    border-radius: 10px;
    font-size: 12px;
    color:#fff;
    pointer-events:none;
    white-space:nowrap;
  }

  .foot{
    font-size: 12px;
    color: var(--muted);
    margin-top:4px;
    line-height:1.3;
    text-align:center;
  }

  @media (max-width: 430px){
    .grid{ grid-template-columns: 1fr; }
    .row2{ grid-template-columns: 1fr; gap: 10px; }
    .statusRow{ flex-direction: column; align-items: stretch; }
    .btn, .selectLike, .toggleWrap, .status, .battBtn{ width: 100%; }
    .hud{ right: 8px; top: 8px; }
  }
</style>
</head>

<body>
<div class="app">
  <div class="header">
    <div class="title">TinZr ECG Viewer</div>
    <button class="battBtn" id="btnBatt">ðŸ”‹ --%</button>
  </div>

  <div class="panel">
    <div class="grid">
      <button class="btn" id="btnFind">Find Devices</button>
      <div class="selectLike" id="selectedDevice">No device selected</div>
    </div>

    <div class="row2">
      <div class="toggleWrap">
        <span>Connect</span>
        <div class="toggle" id="tglConnect"><div class="knob"></div></div>
      </div>
      <div class="toggleWrap">
        <span>Stream ECG</span>
        <div class="toggle" id="tglStream"><div class="knob"></div></div>
      </div>
      <div class="toggleWrap">
        <span>Record</span>
        <div class="toggle" id="tglRecord"><div class="knob"></div></div>
      </div>
    </div>

    <div class="statusRow">
      <button class="btn" id="btnFlip" aria-pressed="true">Flip ECG</button>
      <div class="status" id="status">Status: Idle</div>
    </div>

    <!-- âœ… NEW: iPhone-safe "open image" button -->
    <button class="btn saveBtn" id="btnOpenImage">Open Saved Image</button>
    <img id="imgPreview" style="display:none; width:100%; margin-top:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.12);" alt="Saved ECG image preview"/>

  </div>

  <div class="plotWrap">
    <div class="hud" id="hud">Fs_out=120.0 Hz | HR: -- bpm</div>
    <canvas id="plot"></canvas>
  </div>

  <div class="foot">
    iPhone: Bluefy/WebBLE requires user tap to open/save files. Use the button after recording.
  </div>
</div>

<script>
/* ================== CONFIG (match your Python) ================== */
const TINZR_BLE_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const TINZR_BLE_RX_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const TINZR_BLE_TX_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";

const DEVICE_PREFIX = "TinZr";
const CMD_START = new Uint8Array([ "S".charCodeAt(0) ]);
const CMD_STOP  = new Uint8Array([ "E".charCodeAt(0) ]);
const CMD_BATT  = new Uint8Array([ "B".charCodeAt(0), "A".charCodeAt(0), "T".charCodeAt(0) ]);

const FRAME_SIZE = 5;

const FS_RESAMP_HZ = 120.0;
const WINDOW_SEC = 5.0;
const UPDATE_MS = 10;
const MAX_RAW_SAMPLES = 40000;

const RECORD_DELAY_SEC = 5;
const RECORD_DURATION_SEC = 30;

/* ================== STATE ================== */
let bleDevice = null;
let gattServer = null;
let rxChar = null;
let txChar = null;

let streaming = false;
let recording = false;

let flipSign = -1.0;
let battPct = null;
let fsEst = null;
let hrBpm = null;

let byteBuf = [];

let sampleCount = 0;
let idxRaw = [];
let ecgRaw = [];

let calibStartTime = null;
let calibStartCount = null;
const CALIB_SAMPLES = Math.floor(4 * FS_RESAMP_HZ);
let calibrating = false;

let recIdxRaw = [];
let recEcgRaw = [];
let recBattRaw = [];

let recordCountdownTimer = null;
let recordStopTimer = null;

/* âœ… NEW: store latest image as blob URL (iPhone requires user tap to open) */
let lastImageUrl = null;
let lastImageDataUrl = null;

/* ================== UI ================== */
const btnFind = document.getElementById("btnFind");
const selectedDeviceEl = document.getElementById("selectedDevice");
const tglConnect = document.getElementById("tglConnect");
const tglStream = document.getElementById("tglStream");
const tglRecord = document.getElementById("tglRecord");
const btnFlip = document.getElementById("btnFlip");
const btnBatt = document.getElementById("btnBatt");
const statusEl = document.getElementById("status");
const hudEl = document.getElementById("hud");
const btnOpenImage = document.getElementById("btnOpenImage");
const imgPreview = document.getElementById("imgPreview");
  
function setStatus(s){ statusEl.textContent = "Status: " + s; }

function setToggle(el, on){
  el.classList.toggle("on", !!on);
  el.dataset.on = on ? "1" : "0";
}
function getToggle(el){ return el.dataset.on === "1"; }

function webBleAvailable(){
  return !!(navigator.bluetooth && navigator.bluetooth.requestDevice);
}

function setBatteryText(){
  if (battPct !== null && battPct >= 0){
    btnBatt.textContent = `ðŸ”‹ ${battPct}%`;
  }else{
    btnBatt.textContent = "ðŸ”‹ --%";
  }
}

function enableControls(){
  btnFind.disabled = !webBleAvailable();

  const hasDevice = !!bleDevice;
  tglConnect.style.pointerEvents = hasDevice ? "auto" : "none";
  tglConnect.style.opacity = hasDevice ? "1.0" : "0.45";

  const connected = !!(gattServer && gattServer.connected && rxChar && txChar);
  tglStream.style.pointerEvents = connected ? "auto" : "none";
  tglStream.style.opacity = connected ? "1.0" : "0.45";

  tglRecord.style.pointerEvents = (connected && streaming) ? "auto" : "none";
  tglRecord.style.opacity = (connected && streaming) ? "1.0" : "0.45";
}

function updateHud(){
  let fsText = (fsEst && fsEst > 0)
    ? `Fs_inâ‰ˆ${fsEst.toFixed(1)} Hz  â†’  Fs_out=${FS_RESAMP_HZ.toFixed(1)} Hz`
    : `Fs_out=${FS_RESAMP_HZ.toFixed(1)} Hz`;
  let hrText = (hrBpm && hrBpm > 0) ? `HR: ${Math.round(hrBpm)} bpm` : "HR: -- bpm";
  hudEl.textContent = `${fsText}   |   ${hrText}`;
}

/* âœ… NEW: open image only on user tap (iOS requirement) */
btnOpenImage.addEventListener("click", () => {
  if (!lastImageDataUrl){
    setStatus("No saved image yet");
    return;
  }
  imgPreview.style.display = "block";
  imgPreview.src = lastImageDataUrl;
  setStatus("Long-press the image below â†’ Save Image.");
});




/* ================== BLE: SELECT DEVICE ================== */
btnFind.addEventListener("click", async () => {
  if (!webBleAvailable()){
    setStatus("Web Bluetooth not available in this browser");
    return;
  }

  try{
    setStatus("Opening device picker...");
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: DEVICE_PREFIX }],
      optionalServices: [TINZR_BLE_SERVICE_UUID]
    });

    bleDevice = device;
    selectedDeviceEl.textContent = device.name || "Selected device";
    setStatus("Device selected");

    setToggle(tglConnect, false);
    setToggle(tglStream, false);
    setToggle(tglRecord, false);

    device.addEventListener("gattserverdisconnected", () => {
      streaming = false;
      recording = false;
      rxChar = null;
      txChar = null;
      gattServer = null;

      if (recordCountdownTimer){ clearInterval(recordCountdownTimer); recordCountdownTimer = null; }
      if (recordStopTimer){ clearTimeout(recordStopTimer); recordStopTimer = null; }

      setToggle(tglConnect, false);
      setToggle(tglStream, false);
      setToggle(tglRecord, false);

      btnOpenImage.style.display = "none";
      imgPreview.style.display = "none";
      imgPreview.src = "";
      lastImageDataUrl = null;
      
      setStatus("Disconnected");
      enableControls();
    });

    enableControls();
  }catch(e){
    setStatus("Picker cancelled / error");
  }
});

/* ================== BLE: CONNECT/DISCONNECT ================== */
async function connectDevice(){
  if (!bleDevice){
    setStatus("No device selected");
    return false;
  }

  try{
    setStatus("Connecting...");
    gattServer = await bleDevice.gatt.connect();

    const svc = await gattServer.getPrimaryService(TINZR_BLE_SERVICE_UUID);
    rxChar = await svc.getCharacteristic(TINZR_BLE_RX_CHAR_UUID);
    txChar = await svc.getCharacteristic(TINZR_BLE_TX_CHAR_UUID);

    await txChar.startNotifications();
    txChar.addEventListener("characteristicvaluechanged", onNotify);

    setStatus("Connected");
    return true;
  }catch(e){
    setStatus("Connect failed");
    rxChar = null; txChar = null; gattServer = null;
    return false;
  }finally{
    enableControls();
  }
}

async function disconnectDevice(){
  try{
    if (txChar){
      try{
        txChar.removeEventListener("characteristicvaluechanged", onNotify);
        await txChar.stopNotifications();
      }catch(_){}
    }
    if (streaming){
      await stopStreaming();
    }
  }catch(_){}

  try{
    if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected){
      bleDevice.gatt.disconnect();
    }
  }catch(_){}

  streaming = false;
  recording = false;
  rxChar = null;
  txChar = null;
  gattServer = null;

  if (recordCountdownTimer){ clearInterval(recordCountdownTimer); recordCountdownTimer = null; }
  if (recordStopTimer){ clearTimeout(recordStopTimer); recordStopTimer = null; }

  setStatus("Disconnected");
  enableControls();
}

tglConnect.addEventListener("click", async () => {
  const wantOn = !getToggle(tglConnect);

  if (wantOn){
    const ok = await connectDevice();
    setToggle(tglConnect, !!ok);
  }else{
    setToggle(tglConnect, false);
    setToggle(tglStream, false);
    setToggle(tglRecord, false);
    await disconnectDevice();
  }

  enableControls();
});

/* ================== BLE: STREAMING ================== */
async function writeCmd(bytes){
  if (!rxChar) throw new Error("No RX characteristic");
  await rxChar.writeValue(bytes);
}

async function startStreaming(){
  if (!rxChar || !txChar || !(gattServer && gattServer.connected)){
    setStatus("Not connected");
    return false;
  }

  try{
    streaming = false;
    byteBuf = [];

    sampleCount = 0;
    idxRaw = [];
    ecgRaw = [];

    fsEst = null;
    calibStartTime = null;
    calibStartCount = null;
    calibrating = true;

    recIdxRaw = [];
    recEcgRaw = [];
    recBattRaw = [];

    hrBpm = null;
    updateHud();

    btnOpenImage.style.display = "none";
    imgPreview.style.display = "none";
    imgPreview.src = "";
    lastImageDataUrl = null;


    await writeCmd(CMD_START);

    streaming = true;
    setStatus("Starting ECG streaming...");
    return true;
  }catch(e){
    streaming = false;
    setStatus("Start cmd error");
    return false;
  }finally{
    enableControls();
  }
}

async function stopStreaming(){
  if (!streaming) return;

  try{ await writeCmd(CMD_STOP); }catch(_){}

  streaming = false;

  if (recording){
    stopRecordingAndSaveImage();
    setToggle(tglRecord, false);
  }

  if (recordCountdownTimer){ clearInterval(recordCountdownTimer); recordCountdownTimer = null; }
  if (recordStopTimer){ clearTimeout(recordStopTimer); recordStopTimer = null; }

  setStatus("Streaming stopped");
  enableControls();
}

tglStream.addEventListener("click", async () => {
  const wantOn = !getToggle(tglStream);

  if (wantOn){
    const ok = await startStreaming();
    setToggle(tglStream, !!ok);
  }else{
    setToggle(tglStream, false);
    await stopStreaming();
  }
  enableControls();
});

/* ================== Battery request ================== */
btnBatt.addEventListener("click", async () => {
  if (!rxChar || !(gattServer && gattServer.connected)){
    setStatus("Connect to TinZrECG to query battery");
    return;
  }
  try{
    await writeCmd(CMD_BATT);
    setStatus("Requested battery refresh");
  }catch(e){
    setStatus("Battery refresh error");
  }
});

/* ================== Flip ================== */
btnFlip.addEventListener("click", () => {
  const pressed = (btnFlip.getAttribute("aria-pressed") === "true");
  const next = !pressed;
  btnFlip.setAttribute("aria-pressed", next ? "true" : "false");
  flipSign = next ? -1.0 : 1.0;
});

/* ================== BLE notifications parsing: <iB ================== */
function readInt32LE(b0,b1,b2,b3){
  const u = (b0) | (b1<<8) | (b2<<16) | (b3<<24);
  return u | 0;
}

function onNotify(ev){
  const dv = ev.target.value;
  const n = dv.byteLength;
  for (let i=0; i<n; i++){
    byteBuf.push(dv.getUint8(i));
  }

  const nFrames = Math.floor(byteBuf.length / FRAME_SIZE);
  if (nFrames <= 0) return;

  for (let f=0; f<nFrames; f++){
    const off = f * FRAME_SIZE;

    const ecg_i = readInt32LE(
      byteBuf[off+0], byteBuf[off+1], byteBuf[off+2], byteBuf[off+3]
    );
    const batt_i = byteBuf[off+4];

    battPct = batt_i;
    setBatteryText();

    if (!streaming) continue;

    sampleCount += 1;
    idxRaw.push(sampleCount);
    ecgRaw.push(ecg_i);

    if (recording){
      recIdxRaw.push(sampleCount);
      recEcgRaw.push(ecg_i);
      recBattRaw.push(batt_i);
    }
  }

  const remaining = byteBuf.length - nFrames * FRAME_SIZE;
  if (remaining > 0) byteBuf = byteBuf.slice(byteBuf.length - remaining);
  else byteBuf = [];

  if (idxRaw.length > MAX_RAW_SAMPLES){
    idxRaw = idxRaw.slice(-MAX_RAW_SAMPLES);
    ecgRaw = ecgRaw.slice(-MAX_RAW_SAMPLES);
  }

  if (streaming && fsEst === null){
    if (calibStartTime === null){
      calibStartTime = performance.now() / 1000.0;
      calibStartCount = sampleCount;
    }else{
      const nSamp = sampleCount - calibStartCount;
      if (nSamp >= CALIB_SAMPLES){
        const tNow = performance.now() / 1000.0;
        const dt = tNow - calibStartTime;
        if (dt > 0){
          fsEst = nSamp / dt;

          idxRaw = [];
          ecgRaw = [];

          recIdxRaw = [];
          recEcgRaw = [];
          recBattRaw = [];

          sampleCount = 0;
          calibStartTime = null;
          calibStartCount = null;
          calibrating = false;

          setStatus("Streaming");
        }
      }
    }
  }
}

/* ================== HR + peaks ================== */
function updateHrAndPeaks(t, y){
  if (!t || !y || y.length < 10){
    hrBpm = null;
    return [];
  }

  let mean = 0;
  for (let i=0;i<y.length;i++) mean += y[i];
  mean /= y.length;

  const sig = new Array(y.length);
  let maxAbs = 0;
  for (let i=0;i<y.length;i++){
    sig[i] = y[i] - mean;
    const a = Math.abs(sig[i]);
    if (a > maxAbs) maxAbs = a;
  }
  if (maxAbs <= 0){
    hrBpm = null;
    return [];
  }

  const thr = 0.4 * maxAbs;
  const peaks = [];
  const refractory = Math.floor(0.3 * FS_RESAMP_HZ);
  let lastPeak = -refractory - 1;

  for (let i=1;i<sig.length-1;i++){
    if (sig[i] > thr && sig[i] >= sig[i-1] && sig[i] >= sig[i+1]){
      if ((i - lastPeak) >= refractory){
        peaks.push(i);
        lastPeak = i;
      }
    }
  }

  if (peaks.length < 2){
    hrBpm = null;
    return peaks;
  }

  const rr = [];
  for (let i=1;i<peaks.length;i++){
    const dt = t[peaks[i]] - t[peaks[i-1]];
    if (dt > 0.3 && dt < 2.5) rr.push(dt);
  }
  if (rr.length === 0){
    hrBpm = null;
    return peaks;
  }

  rr.sort((a,b)=>a-b);
  const rrMed = rr[Math.floor(rr.length/2)];
  hrBpm = rrMed > 0 ? (60.0 / rrMed) : null;

  return peaks;
}

/* ================== Plot (Canvas) ================== */
const canvas = document.getElementById("plot");
const ctx = canvas.getContext("2d");

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

function drawPlot(t, y, peaksIdx){
  const w = canvas.getBoundingClientRect().width;
  const h = canvas.getBoundingClientRect().height;

  ctx.clearRect(0,0,w,h);

  const left = 46;
  const right = 12;
  const top = 12;
  const bottom = 28;

  const plotW = w - left - right;
  const plotH = h - top - bottom;

  ctx.fillStyle = "#020817";
  ctx.fillRect(0,0,w,h);

  ctx.fillStyle = "#E0E8FF";
  ctx.font = "12px system-ui";

  ctx.save();
  ctx.translate(14, top + plotH/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = "center";
  ctx.fillText("ECG", 0, 0);
  ctx.restore();

  ctx.textAlign = "center";
  ctx.fillText("Time (s)", left + plotW/2, h - 8);

  if (!t || !y || y.length < 2) return;

  let vmin = Infinity, vmax = -Infinity;
  for (let i=0;i<y.length;i++){
    if (y[i] < vmin) vmin = y[i];
    if (y[i] > vmax) vmax = y[i];
  }
  let center = 0.5*(vmin+vmax);
  let halfRange = 0.5*(vmax-vmin) * 3.0;
  if (halfRange < 1e-6) halfRange = 1.0;

  const yLow = center - halfRange;
  const yHigh = center + halfRange;

  const xMin = 0.0, xMax = WINDOW_SEC;

  function xPix(x){ return left + (x - xMin) * (plotW / (xMax - xMin)); }
  function yPix(v){ return top + (yHigh - v) * (plotH / (yHigh - yLow)); }

  ctx.strokeStyle = "#F5F5F5";
  ctx.lineWidth = 1.4;
  ctx.beginPath();
  for (let i=0;i<y.length;i++){
    const xp = xPix(t[i]);
    const yp = yPix(y[i]);
    if (i===0) ctx.moveTo(xp, yp);
    else ctx.lineTo(xp, yp);
  }
  ctx.stroke();

  if (peaksIdx && peaksIdx.length){
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "#FF5252";
    ctx.fillStyle = "#FFCDD2";

    for (const i of peaksIdx){
      const xp = xPix(t[i]);
      const yp = yPix(y[i]);
      ctx.beginPath();
      ctx.arc(xp, yp, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
  }
}

/* ================== Resample + update loop ================== */
function updateLoop(){
  updateHud();

  if (fsEst === null || calibrating) {
    drawPlot(null, null, null);
    return;
  }

  const n = Math.min(idxRaw.length, ecgRaw.length);
  if (n < 2){
    drawPlot(null, null, null);
    return;
  }

  const fsRaw = fsEst;
  const idx = idxRaw.slice(-n);
  const yRaw = ecgRaw.slice(-n);

  const idxLast = idx[idx.length-1];
  const tRaw = new Array(idx.length);
  for (let i=0;i<idx.length;i++){
    tRaw[i] = (idx[i] - idxLast) / fsRaw;
  }

  const tMin = -WINDOW_SEC;
  let start = 0;
  while (start < tRaw.length && tRaw[start] < tMin) start++;
  if ((tRaw.length - start) < 2){
    drawPlot(null, null, null);
    return;
  }

  const tWindow = tRaw.slice(start);
  const yWindow = yRaw.slice(start);

  const t0 = tWindow[0];
  const tShift = tWindow.map(v => v - t0);

  const nDs = Math.max(2, Math.floor(WINDOW_SEC * FS_RESAMP_HZ));
  const tDs = new Array(nDs);
  for (let i=0;i<nDs;i++){
    tDs[i] = i / FS_RESAMP_HZ;
  }

  const yDs = new Array(nDs);
  let j = 0;
  for (let i=0;i<nDs;i++){
    const x = tDs[i];
    while (j < tShift.length-2 && tShift[j+1] < x) j++;

    const x0 = tShift[j];
    const x1 = tShift[j+1];
    const y0 = yWindow[j];
    const y1 = yWindow[j+1];

    let yi = y0;
    if (x1 > x0){
      const a = (x - x0) / (x1 - x0);
      yi = y0 + a*(y1 - y0);
    }
    yDs[i] = yi * flipSign;
  }

  const peaks = updateHrAndPeaks(tDs, yDs);
  drawPlot(tDs, yDs, peaks);
}
setInterval(updateLoop, UPDATE_MS);

/* ================== Record: 5s countdown, 30s capture, save PNG ================== */
async function startRecordingCountdown(){
  if (!streaming){
    setStatus("Start streaming before recording");
    return false;
  }

  if (recordCountdownTimer){ clearInterval(recordCountdownTimer); recordCountdownTimer = null; }
  if (recordStopTimer){ clearTimeout(recordStopTimer); recordStopTimer = null; }

  recIdxRaw = [];
  recEcgRaw = [];
  recBattRaw = [];
  recording = false;

  btnOpenImage.style.display = "none";

  let remaining = RECORD_DELAY_SEC;
  setStatus(`Recording starts in ${remaining}s`);

  recordCountdownTimer = setInterval(() => {
    remaining -= 1;

    if (remaining > 0){
      setStatus(`Recording starts in ${remaining}s`);
      return;
    }

    clearInterval(recordCountdownTimer);
    recordCountdownTimer = null;

    recording = true;
    setStatus(`Recording... (${RECORD_DURATION_SEC}s)`);

    recordStopTimer = setTimeout(() => {
      stopRecordingAndSaveImage();
      setToggle(tglRecord, false);
      enableControls();
    }, RECORD_DURATION_SEC * 1000);

  }, 1000);

  return true;
}

function stopRecordingAndSaveImage(){
  if (recordCountdownTimer){ clearInterval(recordCountdownTimer); recordCountdownTimer = null; }
  if (recordStopTimer){ clearTimeout(recordStopTimer); recordStopTimer = null; }

  if (!recording){
    setStatus("Recording cancelled");
    return;
  }

  recording = false;

  const n = recEcgRaw.length;
  if (n < 10){
    setStatus("Recording too short");
    return;
  }

  setStatus("Preparing imageâ€¦");

  const widthPerSecond = 220;
  const width = Math.max(1400, Math.floor(widthPerSecond * RECORD_DURATION_SEC));
  const height = 420;

  const out = document.createElement("canvas");
  out.width = width;
  out.height = height;
  const c = out.getContext("2d");

  c.fillStyle = "#020817";
  c.fillRect(0, 0, width, height);

  c.fillStyle = "#E3F2FD";
  c.font = "18px system-ui";
  c.fillText("TinZr ECG â€“ 30s Recording", 16, 28);

  c.font = "13px system-ui";
  const battText = (battPct !== null) ? `Battery: ${battPct}%` : "Battery: --%";
  const fsText = (fsEst && fsEst > 0) ? `Fs_inâ‰ˆ${fsEst.toFixed(1)} Hz` : "Fs_inâ‰ˆ-- Hz";
  c.fillText(`${fsText}   |   ${battText}`, 16, 50);

  const left = 40, right = 16, top = 70, bottom = 30;
  const plotW = width - left - right;
  const plotH = height - top - bottom;

  let vmin = Infinity, vmax = -Infinity;
  for (let i=0;i<n;i++){
    const v = recEcgRaw[i] * flipSign;
    if (v < vmin) vmin = v;
    if (v > vmax) vmax = v;
  }
  let center = 0.5*(vmin+vmax);
  let halfRange = 0.5*(vmax-vmin) * 3.0;
  if (halfRange < 1e-6) halfRange = 1.0;

  const yLow = center - halfRange;
  const yHigh = center + halfRange;

  function xPix(i){ return left + (i / (n-1)) * plotW; }
  function yPix(v){ return top + (yHigh - v) * (plotH / (yHigh - yLow)); }

  c.fillStyle = "#E0E8FF";
  c.font = "14px system-ui";
  c.save();
  c.translate(16, top + plotH/2);
  c.rotate(-Math.PI/2);
  c.textAlign = "center";
  c.fillText("ECG", 0, 0);
  c.restore();

  c.textAlign = "center";
  c.fillText("Time (s)", left + plotW/2, height - 10);

  c.strokeStyle = "#F5F5F5";
  c.lineWidth = 1.6;
  c.beginPath();
  for (let i=0;i<n;i++){
    const v = recEcgRaw[i] * flipSign;
    const xp = xPix(i);
    const yp = yPix(v);
    if (i===0) c.moveTo(xp, yp);
    else c.lineTo(xp, yp);
  }
  c.stroke();

  out.toBlob(blob => {
  // Convert blob -> dataURL (most compatible for iOS open/save flows)
  const reader = new FileReader();
  reader.onload = () => {
    lastImageDataUrl = reader.result;

    // show button + preview (preview helps when popups are blocked)
    btnOpenImage.style.display = "block";
    imgPreview.style.display = "block";
    imgPreview.src = lastImageDataUrl;

    setStatus("Image ready. Tap 'Open Saved Image' or long-press preview â†’ Save Image.");
  };
  reader.readAsDataURL(blob);
}, "image/png");

}

/* Record toggle wiring */
tglRecord.addEventListener("click", async () => {
  const wantOn = !getToggle(tglRecord);

  if (wantOn){
    const ok = await startRecordingCountdown();
    setToggle(tglRecord, !!ok);
  }else{
    setToggle(tglRecord, false);
    stopRecordingAndSaveImage();
  }
  enableControls();
});

/* init */
setToggle(tglConnect, false);
setToggle(tglStream, false);
setToggle(tglRecord, false);
setBatteryText();
enableControls();
</script>
</body>
</html>



